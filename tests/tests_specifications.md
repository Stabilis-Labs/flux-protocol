
# Tests Specifications
In this file, we outline how to write tests for the Flux Protocol, a collection of Scrypto (Radix DLT) blueprints, that enable a CDP stablecoin called fUSD.

## Flux Protocol Setup
 The Flux Protocol consists of 4 big components:
1. flux_component.rs: holds all logic as to opening CDPs and modifying them, and getting data from the protocol.
2. stability_pools.rs: can communicate with the flux_component.rs to call protected methods, such as liquidations and redemptions, and calls them appropriately. These are seperated to allow for swapping out redemtpion / liquidation logic.
3. flash_loans.rs: used to take flash loans from the flux_component.rs
4. proxy.rs: can be used to interact with all components above. Most methods in the components above aren't callable by the end user, and we go through the proxy to call them, as the proxy component holds the badge that is necessary to call them. This allows us to change proxy's if we want to change logic of components after deploying, as component's are immutable.

All components are instantiated through the proxy component.

We can run all tests with "scrypto test" or an individual test using "scrypto test - <test_name> -- --nocapture". There are already some tests written, please have a look at those to see how tests are structured using scrypto-test.

## Writing tests

## Proxy (already written)

These are the tests I want to write (some are already written):
1. To interact with the protocol, we first have to set it up. We do this through calling the new() function on the proxy.rs component. For this we need an oracle component, we can instantiate this from the ./dummy_oracle_component package. We also need a centralized_stablecoin_address. Let's create a new token in our test setup, that will be a placeholder for this address, let's call it USDC. We also need to create 2 other tokens, that can act as placeholder collaterals. Call the first one XRD, and the second one LSULP. Calling the new() function with these parameters returns addresses for all newly created components, that we will interact with to test the Flux Protocol. To finish the set up, let's also call the new_collateral() method for both newly created collaterals. This should cause the protocol to accept these collaterals now.
2. Let's now test opening CDPs. We can call the open_cdp() method on the Proxy component for this. The message and signature are always irrelevant, these normally contain price oracle data, but we use our dummy oracle. To change the price of a dummy oracle collateral, we can still call the set_price() method to manually set a price inside of the oracle (use "LSULP" and "XRD" as market_id for this method). So, if we want to do any testing related to price, we use that. So, now to open a cdp, call the open_cdp method, and test whether everything works correctly. You can write multiple tests for different test cases. We can get the CDP data by calling the get_cdps_info() method on the flux_component.rs component. Use this to verify everything went correctly. We also want to test opening a CDP with too little collateral, to test this is not allowed. Additionally we want to test that we cannot pick the interest dec!(-420) if not a privileged borrower. Finally, we want to test we can borrow at dec!(-420) when a privileged borrower. And also actually, we want to test whether using a non-accepted collateral will fail!
3. Now, let's test the close_cdp() method, we can do this by opening a cdp first, and then calling the method using the proxy.rs component. Test whether all works as we expect it to when closing normally. Test whether closing with too little collateral fails. Also test closing with the wrong token, this should also fail.
4. Let's also try the partial_close_cdp() method on the Proxy component, and test whether everything works as expected. Remember, we can use the get_cdps_data() method on the flux_component.rs to verify things. We should test whether fully closing (with enough fUSD) just functions like a normal close_cdp(). We should also test closing part of it (this doesn't return collateral or fUSD). We should also test closing with a wrong token (not fUSD), that should fail.
5. Let's test borrow_more() as well. We should just do it normally, borrow more than we are allowed to (should fail) and as a privileged borrower (this should not incur any additional borrowing fee, and debt should be equal to borrowed amount).
6. Let's test changing the interest rate of a loan as well (change_cdp_interest()). We should do this normally, which should incur an extra fee. We should also do it after 10 days, which should not incur an extra fee, as the cooldown on changing interest rates is over by then. We should also do it as a privileged borrower from a positive interest rate to dec!(-420), this should be possible. Try this as a non-privileged borrower as well, then it should fail.
7. Let's test top_up_cdp(), this should increase the collateral in the CDP. Try with the wrong resource as well, this should fail.
8. Let's try remove_collateral(), this should work if done a little. Try removing too much collateral, this should fail.
9. Let's try set_max_vec_length(). Without using it, try making 4 of the same CDPs. This should be okay. Then try set_max_vec_length() to 3, and create 4 of the same CDPs again. The last CDP creation should fail.
10. Let's try edit_collateral(). Set the acceptance of a collateral to false, and try to open a CDP with it, this should fail. We should also try borrowing more after setting acceptance to false, this should also fail. Let's also change the mcr with the edit_collateral(), try opening a CDP that should normally be possible before editing, then edit the mcr to something rediculously high, and opening a CDP again, this should then fail.
11. Finally, let's test the tag_irredeemable() method. First, we open a CDP as a privileged borrower, with interest dec!(-420). Then, use edit_privileged_borrower() (disable the auth module to do this, it's an admin method only) to not allow redemption_opt_out anymore. Then try the tag_irredeemable() on the CDP we just opened, this should work, test it did.

## Stability Pools (TO-DO)
Before writing actual tests for the Stability Pools, let's explain how these work:
Stability Pools are used for liquidations using their fUSD. Stability Pools can be bought into by depositing stablecoin (fUSD), however, these Stability Pools consist of the collateral and stablecoin at the same time. For example, a Stability Pool might consist of 1 fUSD and 2 XRD. If you want to 1 fUSD, you have to buy the collateral (XRD) from the Stability Pool with fUSD first, such that your_bought_collateral / your_leftover_fusd = collateral_leftover_in_pool / fusd_leftover_in_pool. In the example of 1 fUSD and 1.5 XRD in Stability Pool, and XRD trading at 1 USD, you'd have to buy approximately 0.5 XRD from the Stability Pool so you can deposit 0.5 fUSD and 0.5 XRD to the Stability Pool . A small thing we haven't kept in mind here, and why I said approximately, is that there is a discount on buying collateral from the Stability Pool: it is priced at 99% of its market value. This price is also available to any person that doesn't want to deposit, but just wants to buy collateral from the Stability Pool using fUSD. They can pay 0.99 * collateral_usd_price in fUSD to buy collateral from the pool in order to make sure the pool is usually only exposed to fUSD. The reason this is alright, is that all collateral in the pools comes from liquidations, and the liquidation fine is 5%, which results in a profit of 4% for Stability Pool depositors still.

Stability Pools also play a role in redemptions. A redemption occurs when someone comes to the protocol with 1 fUSD, and asks for 1 dollar in value of collateral. They pay a small fee, but the CDP with lowest interest rate is used to take collateral from. In return, the CDP's debt is lowered. Using this mechanism, we can ensure the stablecoin is always worth more than 1 dollar. Stability Pools are used to calculate the split of collaterals returned to redeemers. We calculate the outside debt of a debt market. For instance, if 100 fUSD is minted against XRD, and 50 fUSD is located in the fUSD/XRD stability pool, the outside debt is 100-50 = 50 fUSD. If the outside debt for LSULP is 20 fUSD, we have a total outside debt of 20+50 = 70 fUSD. If a redemption occurs, 20/70 should be used to redeem against LSULP and 50/70 against XRD.

The Stability Pools incorporate one additional safety feature: panic mode. If we cannot liquidate with funds from stability pool, we try to enter panic_mode. After trying to enter panic mode, we must wait for a set amount of time (currently set to 1 day), to actually enter panic_mode by proving that we still cannot liquidate with stability pool funds. We cannot wait for more than 2 days to prove this. Once entered, panic_mode is active for 1 day (this is reset every time a panic liquidation occurs). Once panic mode is in effect, we can mint 1 fUSD using 1 centralized stablecoin (let's say USDC for now), and then this minted fUSD is used for liquidations. If redemptions occur, and there is USDC inside of the component, due to liquidations in panic mode, USDC should be redeemed against before actually redeeming against normal (LSULP/XRD) loans.

The Stability Pools can charge interest over the loans in the protocol. This interest is distributed over Stability Pool depositors, and goes into the liquidity providers vault (we use this to reward fUSD LP'ers in a seperate smart contract) and a vault that goes towards the owner of the protocol.

Let's now describe what tests I want to run:
1. contribute_to_pool(): I want to test contributing to the pool when it's empty, when there's only fUSD in it, when there's only collateral in it, when there's VERY LITTLE (dust) collateral in it compared to fUSD and when there's VERY LITTLE (dust) fUSD in it compared to collateral. You should always fill up the pool using contribute_to_pool() first, however, if you want to do manipulations to it after that, we can use the protected_withdraw() and protected_deposit() methods, though we need to disable the auth module for that first.
2. withdraw_from_pool(): we need to check whether we actually get back enough tokens when withdrawing from a pool, test a couple of situations, also after charge_interest(), so we can see that we actually gain fUSD from depositing into these stability pools.
3. buy_collateral_from_pool(): let's try buying collateral from the pool, and whether it works. Also try buying more collateral than there is in the pool, and test what happens. We should be returned our payment that we cannot use.
4. charge_interest(): check whether interest is correctly being charged. Check all situations you can think of.
5. liquidate(): there are many different situations which we need to try liquidations for. Firstly, privileged borrowers with a liquidation notice: try to liquidate them, which should mark them. We need a seperate test for liquidating them too early after marking (should fail), liquidating them after waiting appropriate amount of time (should succeed), trying to liquidate them after waiting appropriate amount of time however the CDP owner has unmarked it by top_up_cdp() and then unmark() in proxy.rs, thus it should fail. Try the last situation again, however, after unmarking we should decrease the collateral price again, which should make it possible to mark them again using liquidate(), and then wait and liquidate() them for real this time. We should also do some tests for normal liquidations. We should be able to liquidate a non-privileged CDP normally, when MCR > CR. We should then also check the retrieve_leftover_collateral() method from proxy.rs to see if we can retrieve collateral that's leftover. We should also check with multiple different CRs and see if the appropriate amount of collateral is used for the liquidation. For instance, when CR > 105% we should liquidate 105% of the collateral. If it's below 105% we should liquidate as much as possible. Also test liquidating a non-privileged that fails because its CR is high enough.
6. Things relating to panic liquidations we should test are: trying to initiate panic mode and then: trying to finalize panic mode by doing it again when 1 < days < 2 have passed, to successfully enter panic mode, and also after more than 2 days which should cause our panic_liquidate() to fail as we haven't successfully entered. The same as the after 2 days should be tested for immediately trying to liquidate (days < 1), to fail to liquidate. After successfully entering panic mode, we should test panic_liquidate() in time (within 1 day) to succeed, and too late (after 1 day) to fail, and also test liquidating after topping up the Stability Pool which causes that there's no need for a panic liquidation anymore, because there is enough fUSD available, thus this should fail. We should also try to initiate panic mode when there is no need to (once because the CDP cannot be liquidated, once because there is enough fUSD available). Finally, we should make sure to test liquidating CDPs we haven't used to enter panic mode, but are still liquidatable. This should be possible, as long as there is not enough fUSD in the stability pool to liquidate them.
7. redemptions(): we should test a redemption which consists of first redeeming some USDC as there was some from panic liquidations, but then also redeems some XRD and LSULP as we still have fUSD leftover. We should also do redemptions which consists of USDC only, and a redemption which consists of XRD and LSULP only. For all of these redemptions, verify whether the returned collateral (or USDC) amount matches the amount we expect it to be. We should also test that privileged borrowers aren't redeemed when there are non-privileged CDPs in the protocol, and that privileged are still redeemed when there are no non-privileged CDPs in the protocol. 

